# 🛡️ 修改防护系统使用指南

**版本**: v1.0  
**创建时间**: 2025-10-31  
**目的**: 彻底解决"修复A功能时破坏B功能"的问题

---

## 🎯 解决的问题

### 痛点

您是否经常遇到：
- ✅ 修复了Bug A
- ❌ 但破坏了功能B
- ❌ 之前修好的功能又出现Bug
- ❌ 甚至导致文件丢失

### 根本原因

1. **AI的"好心办坏事"**
   - 修复A时，发现B也有问题，"顺便"修改
   - 优化代码时，影响了其他功能
   - 没有严格限制修改范围

2. **缺乏技术防护**
   - 只有规则约束（CORE-002）
   - 没有自动检测机制
   - 没有强制阻止机制

---

## 🛡️ 防护体系

### 三层防护

```
┌─────────────────────────────────────────┐
│  第一层：修改前范围验证 (Pre-Check)     │
│  ✓ 声明修改范围                          │
│  ✓ 验证文件数量                          │
│  ✓ 设置允许列表                          │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│  第二层：修改时实时监控 (During-Check)  │
│  ✓ 拦截所有文件修改                      │
│  ✓ 检查是否在允许列表                    │
│  ✓ 超出范围立即阻止                      │
└─────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────┐
│  第三层：修改后验证 (Post-Check)        │
│  ✓ 生成修改报告                          │
│  ✓ 列出所有修改                          │
│  ✓ 标记越界修改                          │
└─────────────────────────────────────────┘
```

---

## 📖 使用方法

### 方法1: 手动模式（AI主动调用）

#### 步骤1: 开始任务前声明范围

```javascript
const { getInstance } = require('./ModificationProtectionSystem');
const protection = getInstance();

// 声明任务和修改范围
protection.validateScope(
    {
        description: '修复统计功能的累加问题',
        targetFiles: [
            'liuxin-mcp-server-unified.js',
            'ResponseInterceptor.js'
        ]
    },
    [
        'liuxin-mcp-server-unified.js',
        'ResponseInterceptor.js'
    ]
);
```

#### 步骤2: 修改代码（自动监控）

系统会自动监控所有文件修改：
- ✅ 修改允许列表中的文件 → 通过
- ❌ 修改其他文件 → **立即阻止 + 警报**

#### 步骤3: 任务完成后生成报告

```javascript
// 生成修改报告
const report = protection.generateReport();

// 保存报告到文件
protection.saveReport();

// 重置（开始新任务）
protection.reset();
```

---

### 方法2: 自动模式（集成到MCP）

**在 `liuxin-mcp-server-unified.js` 中集成**：

```javascript
// 加载修改防护拦截器
const ModificationProtectionInterceptor = require('./ModificationProtectionInterceptor');
const protectionInterceptor = new ModificationProtectionInterceptor();

// 在工具调用前检查
function handleToolCall(toolName, args) {
    // 1. 检查修改防护
    const protectionResult = protectionInterceptor.intercept(toolName, args);
    if (protectionResult.blocked) {
        console.error(protectionResult.feedback);
        throw new Error('MODIFICATION_BLOCKED: ' + protectionResult.message);
    }
    
    // 2. 继续正常流程
    // ...
}
```

---

## 🧪 测试示例

### 场景1: 正常修改（允许）

```javascript
const protection = getInstance();

// 声明任务
protection.validateScope(
    { description: '修复登录功能' },
    ['login.js', 'auth.js']
);

// 修改允许的文件
protection.checkModification('login.js', 'write');
// ✅ 结果：允许

protection.checkModification('auth.js', 'search_replace');
// ✅ 结果：允许
```

### 场景2: 越界修改（阻止）

```javascript
// 继续上面的任务

// 尝试修改不在范围内的文件
protection.checkModification('profile.js', 'write');
// ❌ 结果：阻止 + 警报

// 控制台输出：
// 🚨 [During-Check] 检测到越界修改！
// ❌ 文件：profile.js
// ❌ 当前任务：修复登录功能
// 🛑 修改已被阻止！
```

---

## 📊 修改报告

### 报告内容

```json
{
  "task": {
    "description": "修复统计功能的累加问题",
    "targetFiles": [
      "liuxin-mcp-server-unified.js",
      "ResponseInterceptor.js"
    ],
    "timestamp": "2025-10-31T12:00:00.000Z"
  },
  "totalModifications": 2,
  "modifiedFiles": [
    {
      "file": "liuxin-mcp-server-unified.js",
      "fullPath": "F:\\...\\liuxin-mcp-server-unified.js",
      "modificationCount": 3
    },
    {
      "file": "ResponseInterceptor.js",
      "fullPath": "F:\\...\\ResponseInterceptor.js",
      "modificationCount": 2
    }
  ],
  "violations": [],
  "hasViolations": false,
  "timestamp": "2025-10-31T12:10:00.000Z"
}
```

### 报告说明

- `totalModifications`: 修改的文件数量
- `modifiedFiles`: 每个文件的修改次数
- `violations`: 越界修改记录
- `hasViolations`: 是否有违规

---

## 🔧 集成步骤

### 步骤1: 在MCP服务器中加载

```javascript
// liuxin-mcp-server-unified.js

const ModificationProtectionInterceptor = require('./ModificationProtectionInterceptor');
const protectionInterceptor = new ModificationProtectionInterceptor();
```

### 步骤2: 集成到工具调用链

```javascript
async function handleToolCall(toolName, args) {
    // 修改防护检查
    const protectionCheck = protectionInterceptor.intercept(toolName, args);
    if (protectionCheck.blocked) {
        return {
            error: protectionCheck.message,
            feedback: protectionCheck.feedback
        };
    }
    
    // 继续正常流程
    // ...
}
```

### 步骤3: AI工作流程更新

**修改前**：
```
AI收到任务 → 直接开始修改代码
```

**修改后**：
```
AI收到任务 
  → 调用 validateScope() 声明范围
  → 修改代码（自动监控）
  → 生成报告
  → 重置防护系统
```

---

## 🎯 最佳实践

### 1. 任务开始前

**必须做**：
- ✅ 调用 `validateScope()` 声明修改范围
- ✅ 只列出任务直接相关的文件
- ✅ 文件数量控制在5个以内

**不要做**：
- ❌ 不声明范围就开始修改
- ❌ 列出"可能"会改的文件
- ❌ 一次性修改太多文件

### 2. 修改代码时

**必须做**：
- ✅ 只修改声明范围内的文件
- ✅ 发现其他问题时先报告
- ✅ 获得授权后再扩大范围

**不要做**：
- ❌ "顺便"修改其他文件
- ❌ 擅自优化其他代码
- ❌ 批量修改多个模块

### 3. 任务完成后

**必须做**：
- ✅ 生成修改报告
- ✅ 检查是否有越界修改
- ✅ 调用 `reset()` 清理状态

---

## ⚠️ 常见问题

### Q1: 发现其他问题时怎么办？

**错误做法**：
```javascript
// ❌ 直接修改
write('other-file.js', newCode);
```

**正确做法**：
```javascript
// 1. 先完成当前任务
// 2. 生成报告
protection.generateReport();
protection.reset();

// 3. 报告其他问题
console.log('发现其他问题：other-file.js 也需要修复');

// 4. 询问用户
console.log('是否需要修复 other-file.js？');

// 5. 获得授权后，开始新任务
protection.validateScope(
    { description: '修复 other-file.js' },
    ['other-file.js']
);
```

### Q2: 修改数量超过5个怎么办？

**建议**：拆分为多个任务

```javascript
// 任务1
protection.validateScope(
    { description: '修复统计功能' },
    ['file1.js', 'file2.js']
);
// ... 修改 ...
protection.reset();

// 任务2
protection.validateScope(
    { description: '修复团队模式' },
    ['file3.js', 'file4.js']
);
// ... 修改 ...
protection.reset();
```

### Q3: 如何临时禁用防护？

```javascript
// 禁用（谨慎使用！）
protection.setEnabled(false);

// 修改代码
// ...

// 重新启用
protection.setEnabled(true);
```

**⚠️ 警告**：禁用防护系统可能导致越界修改！

---

## 📈 效果对比

### 使用前

| 场景         | 结果               |
| ------------ | ------------------ |
| 修复统计功能 | ❌ 团队模式也被改了 |
| 优化锁管理器 | ❌ 响应拦截器坏了   |
| 添加新功能   | ❌ 3个旧功能出Bug   |

### 使用后

| 场景         | 结果                 |
| ------------ | -------------------- |
| 修复统计功能 | ✅ 只改了统计相关文件 |
| 优化锁管理器 | ✅ 只改了锁管理器     |
| 添加新功能   | ✅ 旧功能不受影响     |

---

## 🔗 相关文档

- [CORE-002规则说明](./.cursorrules) - 严禁越界修改
- [锁管理器](./locks/README.md) - 模块级保护
- [系统文档](./📘【柳芯系统完整文档】.json)

---

## 📝 更新历史

| 版本 | 日期       | 更新内容         |
| ---- | ---------- | ---------------- |
| v1.0 | 2025-10-31 | 创建修改防护系统 |

---

**维护者**: 柳芯系统开发团队  
**最后更新**: 2025-10-31

